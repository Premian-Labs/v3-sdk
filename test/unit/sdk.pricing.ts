import { BigNumberish, parseEther, toBigInt, ZeroAddress } from 'ethers'
import { expect } from 'chai'
import sinon from 'sinon'
import moment from 'moment/moment'

import {
	Addresses,
	IPoolFactory__factory,
	Premia,
	QuoteOrFillableQuoteT,
	SupportedChainId,
} from '../../src'

const dotenv = require('dotenv')
dotenv.config()

interface PoolKey {
	base: string
	quote: string
	oracleAdapter: string
	strike: BigNumberish
	maturity: BigNumberish
	isCallPool: boolean
}

const now = Math.floor(new Date().getTime() / 1000)
const ONE_HOUR = 3600
const strike = 1800

const baseQuote: QuoteOrFillableQuoteT = {
	poolKey: {
		base: '',
		quote: '',
		oracleAdapter: '',
		strike: 0n,
		maturity: 0n,
		isCallPool: true,
	},
	provider: ZeroAddress,
	taker: ZeroAddress,
	price: parseEther('0'),
	size: parseEther('0'),
	isBuy: false,
	deadline: toBigInt(now),
	salt: 0n,
	poolAddress: '',
	approvalTarget: '',
	approvalAmount: 0n,
	to: '',
	data: '0x',
}

describe('PricingAPI', function (this: any) {
	let premia: Premia
	let poolKey: PoolKey

	// Private key generated by anvil just used for testing
	let privateKey =
		'0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80'
	const emitWarningStub = sinon.stub(process, 'emitWarning')

	this.timeout(10000)

	before(async () => {
		premia = await Premia.initialize({
			privateKey: privateKey,
			provider: 'http://127.0.0.1:8545',
			chainId: SupportedChainId.ARBITRUM_GOERLI,
		})

		// Deploy a pool
		const poolFactory = await IPoolFactory__factory.connect(
			premia.contracts.poolFactoryAddress,
			premia.signer
		)

		const maturity = moment()
			.utcOffset(0)
			.add(7, 'd')
			.day(5)
			.set({ hour: 8, minute: 0, second: 0, millisecond: 0 })
		const maturitySec = maturity.valueOf() / 1000

		poolKey = {
			base: Addresses[premia.chainId].WETH,
			quote: Addresses[premia.chainId].USDC,
			oracleAdapter: Addresses[premia.chainId].CHAINLINK_ORACLE_ADAPTER,
			strike: parseEther(strike.toString()),
			maturity: maturitySec,
			isCallPool: true,
		}

		let [, isDeployed] = await poolFactory.getPoolAddress(poolKey)

		if (!isDeployed) {
			await poolFactory.deployPool(poolKey, {
				value: parseEther('1'), //init fee. excess refunded
			})
		}
	})

	describe('#better', async () => {
		it('should provide a warning if different pool keys are used', async () => {
			const rfqQuote1: QuoteOrFillableQuoteT = {
				...baseQuote,
				price: parseEther('0.1'),
				size: parseEther('5'),
				createdAt: now - ONE_HOUR,
				deadline: toBigInt(now + ONE_HOUR),
			}

			const rfqQuote2: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('5'),
				createdAt: now - ONE_HOUR,
				deadline: toBigInt(now + ONE_HOUR),
			}

			premia.pricing.better(
				rfqQuote1,
				rfqQuote2,
				parseEther('3'),
				parseEther('1')
			)

			expect(emitWarningStub.calledOnce).to.be.true
			expect(
				emitWarningStub.calledWith(
					'Pool keys for quotes compared are not identical'
				)
			).to.be.true

			emitWarningStub.restore()
		})
		it('should pick quote that hasnt expired', async () => {
			const rfqQuote1: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('5'),
				createdAt: now - 2 * ONE_HOUR,
				deadline: toBigInt(now - ONE_HOUR),
			}

			const rfqQuote2: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('5'),
				createdAt: now,
				deadline: toBigInt(now + ONE_HOUR),
			}

			const bestQuote = premia.pricing.better(
				rfqQuote1,
				rfqQuote2,
				parseEther('3'),
				parseEther('1')
			)
			expect(bestQuote).to.deep.eq(rfqQuote2)
		})

		it('should return null when comparing two expired quotes', async () => {
			const rfqQuote1: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('5'),
				createdAt: now - 2 * ONE_HOUR,
				deadline: toBigInt(now - ONE_HOUR),
			}
			const rfqQuote2: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('5'),
				createdAt: now - 2 * ONE_HOUR,
				deadline: toBigInt(now - ONE_HOUR),
			}

			const bestQuote = premia.pricing.better(
				rfqQuote1,
				rfqQuote2,
				parseEther('3'),
				parseEther('1')
			)
			expect(bestQuote).to.deep.eq(null)
		})
		it('should pick quote that satisifies minSize', async () => {
			const rfqQuote1: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('3'),
				createdAt: now - ONE_HOUR,
				deadline: toBigInt(now + ONE_HOUR),
			}
			const rfqQuote2: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('1'),
				createdAt: now - ONE_HOUR,
				deadline: toBigInt(now + ONE_HOUR),
			}

			const bestQuote = premia.pricing.better(
				rfqQuote1,
				rfqQuote2,
				parseEther('3'),
				parseEther('2')
			)
			expect(bestQuote).to.deep.eq(rfqQuote1)
		})
		it('should pick quote that satisfies size when minSize is not provided', async () => {
			const rfqQuote1: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.12'),
				size: parseEther('2'),
				createdAt: now - ONE_HOUR,
				deadline: toBigInt(now + ONE_HOUR),
			}
			const rfqQuote2: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('3'),
				createdAt: now - ONE_HOUR,
				deadline: toBigInt(now + ONE_HOUR),
			}

			const bestQuote = premia.pricing.better(
				rfqQuote1,
				rfqQuote2,
				parseEther('3')
			)
			expect(bestQuote).to.deep.eq(rfqQuote2)
		})
		it('should throw error if input minimumSize > size', async () => {
			const rfqQuote1: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.11'),
				size: parseEther('6'),
				createdAt: now - ONE_HOUR,
				deadline: toBigInt(now + ONE_HOUR),
			}
			const rfqQuote2: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('5'),
				createdAt: now - ONE_HOUR,
				deadline: toBigInt(now + ONE_HOUR),
			}

			expect(() =>
				premia.pricing.better(
					rfqQuote1,
					rfqQuote2,
					parseEther('3'),
					parseEther('7')
				)
			).to.throw('Minimum size cannot be greater than size')
		})
		it('should return null if neither quote satisifies minimumSize', async () => {
			const rfqQuote1: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('2'),
				createdAt: now,
				deadline: toBigInt(now + ONE_HOUR),
			}
			const rfqQuote2: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('1'),
				createdAt: now,
				deadline: toBigInt(now + ONE_HOUR),
			}

			const bestQuote = premia.pricing.better(
				rfqQuote1,
				rfqQuote2,
				parseEther('3'),
				parseEther('3')
			)
			expect(bestQuote).to.deep.eq(null)
		})
		it('should return a pool quote if rfq quote is expired (rfq vs pool)', async () => {
			const poolQuote1: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('4'),
				deadline: toBigInt(now + ONE_HOUR),
			}
			const rfqQuote2: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.11'),
				size: parseEther('5'),
				createdAt: now - 2 * ONE_HOUR,
				deadline: toBigInt(now - ONE_HOUR),
			}

			const bestQuote = premia.pricing.better(
				poolQuote1,
				rfqQuote2,
				parseEther('3')
			)
			expect(bestQuote).to.deep.eq(poolQuote1)
		})
		it('should return null if rfq quote is expired and pool quote violates size', async () => {
			const poolQuote1: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('2'),
				deadline: toBigInt(now + ONE_HOUR),
			}
			const rfqQuote2: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.11'),
				size: parseEther('5'),
				createdAt: now - 2 * ONE_HOUR,
				deadline: toBigInt(now - ONE_HOUR),
			}

			const bestQuote = premia.pricing.better(
				poolQuote1,
				rfqQuote2,
				parseEther('3')
			)
			expect(bestQuote).to.deep.eq(null)
		})
		it('should pick quote that is better price', async () => {
			const rfqQuote1: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('3'),
				createdAt: now,
				deadline: toBigInt(now + ONE_HOUR),
			}
			const rfqQuote2: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.11'),
				size: parseEther('3'),
				createdAt: now,
				deadline: toBigInt(now + ONE_HOUR),
			}

			const bestQuote = premia.pricing.better(
				rfqQuote1,
				rfqQuote2,
				parseEther('3'),
				parseEther('1')
			)
			expect(bestQuote).to.deep.eq(rfqQuote2)
		})
		it('should give final tiebreaker to quote A (pool vs pool)', async () => {
			const poolQuote1: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('3'),
				deadline: toBigInt(now + ONE_HOUR),
				salt: 123n,
			}

			const poolQuote2: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('3'),
				deadline: toBigInt(now + ONE_HOUR),
				salt: 456n,
			}

			const bestQuote = premia.pricing.better(
				poolQuote1,
				poolQuote2,
				parseEther('3'),
				parseEther('1')
			)
			expect(bestQuote).to.deep.eq(poolQuote1)
		})
		it('should give final tiebreaker to pool/vault (rfq vs pool/vault)', async () => {
			const rfqQuote1: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('3'),
				createdAt: now,
				deadline: toBigInt(now + ONE_HOUR),
				salt: 123n,
			}

			const poolQuote2: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('3'),
				deadline: toBigInt(now + ONE_HOUR),
				salt: 456n,
			}

			const bestQuote = premia.pricing.better(
				rfqQuote1,
				poolQuote2,
				parseEther('3'),
				parseEther('1')
			)
			expect(bestQuote).to.deep.eq(poolQuote2)
		})
		it('should give rfq tiebreaker to fifo (rfq vs rfq)', async () => {
			const rfqQuote1: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('3'),
				createdAt: now - ONE_HOUR,
				deadline: toBigInt(now + ONE_HOUR),
				salt: 123n,
			}
			const rfqQuote2: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('3'),
				createdAt: now,
				deadline: toBigInt(now + ONE_HOUR),
				salt: 456n,
			}

			const bestQuote = premia.pricing.better(
				rfqQuote1,
				rfqQuote2,
				parseEther('3'),
				parseEther('1')
			)
			expect(bestQuote).to.deep.eq(rfqQuote1)
		})
		it('should give final rfq tiebreaker to quote A (rfq vs rfq)', async () => {
			const rfqQuote1: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('3'),
				createdAt: now,
				deadline: toBigInt(now + ONE_HOUR),
				salt: 123n,
			}

			const rfqQuote2: QuoteOrFillableQuoteT = {
				...baseQuote,
				poolKey: poolKey,
				price: parseEther('0.1'),
				size: parseEther('3'),
				createdAt: now,
				deadline: toBigInt(now + ONE_HOUR),
				salt: 456n,
			}

			const bestQuote = premia.pricing.better(
				rfqQuote1,
				rfqQuote2,
				parseEther('3'),
				parseEther('1')
			)
			expect(bestQuote).to.deep.eq(rfqQuote1)
		})
	})

	describe('#best', async () => {
		it('should provide a warning if different pool keys are used', async () => {
			const quotes: QuoteOrFillableQuoteT[] = [
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					createdAt: now,
					deadline: toBigInt(now + ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('4'),
					createdAt: now,
					deadline: toBigInt(now + ONE_HOUR),
				},
				{
					...baseQuote,
					price: parseEther('0.1'),
					size: parseEther('5'),
					createdAt: now,
					deadline: toBigInt(now + ONE_HOUR),
				},
			]

			premia.pricing.best(quotes, parseEther('3'), parseEther('2'))

			expect(emitWarningStub.calledOnce).to.be.true
			expect(
				emitWarningStub.calledWith(
					'Pool keys for quotes compared are not identical'
				)
			).to.be.true

			emitWarningStub.restore()
		})
		it('should pick quote that hasnt expired', async () => {
			const quotes: QuoteOrFillableQuoteT[] = [
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					createdAt: now - 2 * ONE_HOUR,
					deadline: toBigInt(now - ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('4'),
					createdAt: now,
					deadline: toBigInt(now + ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('5'),
					createdAt: now - 2 * ONE_HOUR,
					deadline: toBigInt(now - ONE_HOUR),
				},
			]
			const bestQuote = premia.pricing.best(
				quotes,
				parseEther('3'),
				parseEther('2')
			)
			expect(bestQuote).to.deep.eq(quotes[1])
		})
		it('should return null if all quotes have expired', async () => {
			const quotes: QuoteOrFillableQuoteT[] = [
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					createdAt: now - 2 * ONE_HOUR,
					deadline: toBigInt(now - ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('4'),
					createdAt: now - 2 * ONE_HOUR,
					deadline: toBigInt(now - ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('5'),
					createdAt: now - 2 * ONE_HOUR,
					deadline: toBigInt(now - ONE_HOUR),
				},
			]

			expect(premia.pricing.best(quotes, parseEther('3'), parseEther('2'))).to
				.be.null
		})
		it('should pick quote that satisifies minSize', async () => {
			const quotes: QuoteOrFillableQuoteT[] = [
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.12'),
					size: parseEther('1'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.11'),
					size: parseEther('1'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('6'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
				},
			]
			const bestQuote = premia.pricing.best(
				quotes,
				parseEther('3'),
				parseEther('2')
			)
			expect(bestQuote).to.deep.eq(quotes[2])
		})
		it('should pick quote that satisfies size when minSize is not provided', async () => {
			const quotes: QuoteOrFillableQuoteT[] = [
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.12'),
					size: parseEther('1'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.11'),
					size: parseEther('3'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('6'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
				},
			]
			const bestQuote = premia.pricing.best(quotes, parseEther('3'))
			expect(bestQuote).to.deep.eq(quotes[1])
		})
		it('should return null if minimumSize/size is not satisfied', async () => {
			const quotes: QuoteOrFillableQuoteT[] = [
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.12'),
					size: parseEther('1'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.11'),
					size: parseEther('3'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('4'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
				},
			]

			expect(premia.pricing.best(quotes, parseEther('6'))).to.be.null

			expect(premia.pricing.best(quotes, parseEther('6'), parseEther('5'))).to
				.be.null
		})
		it('should return a pool quote if rfq quote is expired (rfq vs pool)', async () => {
			const quotes: QuoteOrFillableQuoteT[] = [
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.12'),
					size: parseEther('1'),
					createdAt: now - 2 * ONE_HOUR,
					deadline: toBigInt(now - ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.11'),
					size: parseEther('3'),
					createdAt: now - 3 * ONE_HOUR,
					deadline: toBigInt(now - ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('4'),
					deadline: toBigInt(now + ONE_HOUR),
				},
			]
			const bestQuote = premia.pricing.best(
				quotes,
				parseEther('3'),
				parseEther('2')
			)
			expect(bestQuote).to.deep.eq(quotes[2])
		})
		it('should return an rfq quote if 1 rfq quote is expired and 1 pool quote violates size', async () => {
			const quotes: QuoteOrFillableQuoteT[] = [
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.12'),
					size: parseEther('1'),
					createdAt: now - 2 * ONE_HOUR,
					deadline: toBigInt(now - ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.11'),
					size: parseEther('3'),
					createdAt: now - 3 * ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.12'),
					size: parseEther('2'),
					deadline: toBigInt(now + ONE_HOUR),
				},
			]
			const bestQuote = premia.pricing.best(quotes, parseEther('3'))
			expect(bestQuote).to.deep.eq(quotes[1])
		})
		it('should pick quote that is better price', async () => {
			const quotes: QuoteOrFillableQuoteT[] = [
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.12'),
					size: parseEther('3'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.111'),
					size: parseEther('3'),
					deadline: toBigInt(now + ONE_HOUR),
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
				},
			]
			const bestQuote = premia.pricing.best(
				quotes,
				parseEther('3'),
				parseEther('2')
			)
			expect(bestQuote).to.deep.eq(quotes[0])
		})
		it('should give final tiebreaker to last identical quote', async () => {
			const poolQuotes: QuoteOrFillableQuoteT[] = [
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					deadline: toBigInt(now + ONE_HOUR),
					salt: 123n,
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					deadline: toBigInt(now + ONE_HOUR),
					salt: 456n,
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					deadline: toBigInt(now + ONE_HOUR),
					salt: 789n,
				},
			]
			const bestPoolQuote = premia.pricing.best(
				poolQuotes,
				parseEther('3'),
				parseEther('2')
			)
			expect(bestPoolQuote).to.deep.eq(poolQuotes[2])

			const rfqQuotes: QuoteOrFillableQuoteT[] = [
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
					salt: 123n,
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
					salt: 456n,
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
					salt: 789n,
				},
			]
			const bestRfqQuote = premia.pricing.best(
				rfqQuotes,
				parseEther('3'),
				parseEther('2')
			)
			expect(bestRfqQuote).to.deep.eq(rfqQuotes[2])
		})
		it('should give final tiebreaker to pool quote', async () => {
			const quotes: QuoteOrFillableQuoteT[] = [
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					deadline: toBigInt(now + ONE_HOUR),
					salt: 123n,
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
					salt: 456n,
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
					salt: 789n,
				},
			]
			const bestPoolQuote = premia.pricing.best(
				quotes,
				parseEther('3'),
				parseEther('2')
			)
			expect(bestPoolQuote).to.deep.eq(quotes[0])
		})
		it('should give rfq tiebreaker to fifo (rfq quotes)', async () => {
			const quotes: QuoteOrFillableQuoteT[] = [
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					createdAt: now - ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
					salt: 123n,
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					createdAt: now - 2 * ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
					salt: 456n,
				},
				{
					...baseQuote,
					poolKey: poolKey,
					price: parseEther('0.1'),
					size: parseEther('3'),
					createdAt: now - 3 * ONE_HOUR,
					deadline: toBigInt(now + ONE_HOUR),
					salt: 789n,
				},
			]
			const bestPoolQuote = premia.pricing.best(
				quotes,
				parseEther('3'),
				parseEther('2')
			)
			expect(bestPoolQuote).to.deep.eq(quotes[2])
		})
	})

	describe('#premiumLimit', async () => {
		let tests = [
			{
				premium: parseEther('100'),
				maxSlippagePercent: 0.05,
				isBuy: true,
				expected: parseEther('105'),
			},
			{
				premium: parseEther('100'),
				maxSlippagePercent: 0,
				isBuy: true,
				expected: parseEther('100'),
			},
			{
				premium: parseEther('100'),
				maxSlippagePercent: 0.05,
				isBuy: false,
				expected: parseEther('95'),
			},
			{
				premium: parseEther('100'),
				maxSlippagePercent: 0,
				isBuy: false,
				expected: parseEther('100'),
			},
			{
				premium: 34043n,
				maxSlippagePercent: 0,
				isBuy: false,
				expected: 36596n,
			},
		]

		tests.forEach((test) => {
			it(`should correctly compute the premium limit for slippage=${test.maxSlippagePercent} and isBuy=${test.isBuy}`, async () => {
				let premiumLimit = premia.pricing.premiumLimit(
					test.premium,
					test.maxSlippagePercent,
					test.isBuy
				)

				expect(premiumLimit).eq(test.expected)
			})
		})
	})
})
